#!/usr/bin/env python3

import argparse
import re

from collections import OrderedDict


LOG_REGEX = re.compile(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d{3})?:\s+')

START_REGEX = re.compile(
    r'Using (?P<cores>\d+) cores on (?P<host>.+)'
    ' to process (?P<events>\d+) events of (?P<file>.+) \[\d+/\d+\]'
)

BENCHMARK_REGEX = re.compile(
    r'(?P<label>\w+)\s+(?P<events>\d+) events\s+'
    'total time =\s+(?P<total_time>\d+\.\d+) s\s+'
    'average event time =\s+(?P<avg_time>\d+\.\d+) ms'
)

ORCH_AVG_TIME_REGEX = re.compile(
    r'Average processing time  =\s+(?P<avg_time>\d+\.\d+) ms'
)


times = OrderedDict()


def nonblank_lines(f):
    for line in f.readlines():
        line = LOG_REGEX.sub('', line.strip())
        if line:
            yield line


def parse_time(log_file):
    with open(log_file) as f:
        benchmark_trial = False
        benchmark_block = False
        for line in nonblank_lines(f):
            if not benchmark_trial:
                match = START_REGEX.match(line)
                if match:
                    cores = int(match.group('cores'))
                    times.setdefault('Cores', []).append(cores)
                    benchmark_trial = True

            if benchmark_trial and not benchmark_block:
                if line.startswith('Benchmark results:'):
                    benchmark_block = True
                    continue

            if benchmark_block:
                match = BENCHMARK_REGEX.match(line)
                if match:
                    label = match.group('label')
                    time = float(match.group('avg_time'))
                    times.setdefault(label, []).append(time)
                    continue
                match = ORCH_AVG_TIME_REGEX.match(line)
                if match:
                    time = float(match.group('avg_time'))
                    times.setdefault('Orchestrator', []).append(time)
                benchmark_trial = False
                benchmark_block = False


def print_results():
    N = 3
    T = int(len(times['TOTAL']) / N)
    print(';'.join(times.keys()))
    for n in range(T):
        i = n * N
        line = '%d' % times['Cores'][i]
        for label in times.keys():
            if label == 'Cores':
                continue
            token_times = [float(v) for v in times[label][i:i+N]]
            token_avg = sum(token_times) / N
            line += ';%.2f' % token_avg
        print(line)


if __name__ == '__main__':

    argparser = argparse.ArgumentParser()
    argparser.add_argument('log_file', help='the multicore-test output')
    args = argparser.parse_args()

    parse_time(args.log_file)
    print_results()
